@code_type ruby .rb
@comment_type # %s
@include layout.lit
@title Computer-aided Day Trading

@s Computer-aided Day Trading

The stock market generally overreacts. When good news is published, the price
rises before subsequently falling some amount. When bad news is published, the
price plummets before subsequently rising some amount. One method of automation
would be scanning the news for headlines, measuring the sentiment, and then
investing when the price drops -- the news tells you where to look. Another
option is to scan the entire market and look for drops.

My method is to do exactly that: scan the entire market for a precipitous drop
in price over two days (opening of the first to closing of the second), and
then invest. These stocks tend to rise, collectively, over 100%. How can I
take advantage of that? How do I know when to sell? When should I be
satisfied with a stock's performance?

The database is discussed [here](/files/db.html).

@s The Process

The process starts simply: we answer the questions of "when do we buy" and "when
do we sell".

A stock price will drop and then it will go back up. We are measuring several
different dimensions for the best outcome, which make this a difficult
(annoying?) problem to solve without the help of more computing power. As an
intermediate step, I've settled on the below figures.

@s When Do We Buy?

What a great question.

We buy when the price drops and we are confident that the price will go back up.

#### Price Drop

First off, what does a "drop in price" look like? What kinds of drops are there?
Reviewing the data from the NYSE for 2019 (1 January - 31 December), we get the
following numbers for the fractional 2-day change (from opening of one day to
the close of the next):

--- Price Change and Occurrences
tids  = Ticker.where(:exchange => 'NYSE').all.map {|t| t.id }
debut = Time.parse('1 jan 2019')
fin   = Time.parse('31 dec 2019')
bars  = Bar.where(:time => debut..fin, :ticker_id => tids)
           .order(:ticker_id, Sequel.asc(:time))
           .all
groups  = bars.group_by {|b| b.ticker_id }
changes = groups.map do |ticker_id, bars|
  bars.each_cons(2).map {|a, b| b.change_from a }
end.flatten

hist = changes.histogram [-0.35, -0.25, -0.15, -0.05, 0.05, 0.15, 0.25, 0.35]
---

--- Price Change and Occurrences :=
"Fractional 2-day Change" => "# of Occurrences"
               -100..-0.3 => 99
               -0.3..-0.2 => 243
               -0.2..-0.1 => 2532
               -0.1.. 0   => 267752
                0  .. 0.1 => 309317
                0.1.. 0.2 => 3218
                0.2.. 0.3 => 377
                0.3.. 100 => 151
---

I therefore decided that the 99 occurrences/year would be sufficient for my
tastes; the odds that a >30% drop is an overreaction due to bad news to some
degree is likely high. Thus: we're set the default value in the simulator as
`-0.3`.

#### Price Movement

The logic here is based on my theory of price change: the price of a stock
changes when enough sales have occurred to raise the price (an unenlightening
statement), with $\Delta P_{min}$ being the minimum increase in a stock's price:

$$\Delta P_{day} = \Delta P_{min} * N_{trades}$$

With a larger minimum price increase, then fewer sales are required to raise the
price to meet a certain threshold. Dividing both sides by $P_{day - 1}$, we get
the fractional change in price:

$$\frac{\Delta P_{day}}{P_{day - 1}} = \frac{\Delta P_{min}}{P_{day - 1}} *
N_{trades}$$

This now represents the fractional ROI. Assuming the $P_{min}$ is constant for
all stocks, $\frac{\Delta P_{min}}{P_{day - 1}}$ will be greater when $P$ is
lower. We want to maximize $N_{trades}$ and minimize $P$, which is summarized in
our maximization of $\frac{N_{trades}}{P_{day - 1}}$, visible in the following
rephrasing:


$$\frac{\Delta P_{day}}{P_{day - 1}} = \Delta P_{min} * \frac{N_{trades}}{P_{day - 1}}$$

The change in price works in both directions, so maximizing the above monomial
could also lead to a sever price drop. But since we're minimizing the $P_{day}$
involved, we're limiting how much the price can drop.

<br/>

**TODO**: This would be a really good thing to check instead of simply volume.
Maybe ensure that a stock is in the top 30% or something? Or meets some minimum
threshold that roughly represents that bracket?

--- Price Theory Optimization
# Make a list of the N_{trades{ / P_{day - 1} values for each company *today*
vals = nyse.inject({}) do |hash, ticker|
  unless ticker.bars.empty?
    hash[ticker] = ticker.volumes(:prior => 10).mean / ticker.bars[-1].close]
  end

  hash
end
---

#### N<sub>trades</sub>

But because I'm an idiot and didn't do sufficient math as I was developing this
program, I only check for $N_{trades}$ instead of $\frac{N_{trades}}{P_{day -
1}}$. 10,000,000 was chosen because after looking at the trades that dropped,
there were more losers than winners in the < 10,000,000 trades/day crowd. I
found that I could increase my average ROI by culling the herd.

--- When Do We Buy?
    @assessor.buy_when :history => 5 do |history|
      today     = history[-1]
      yesterday = history[-2]
    
      [[today.change_from(yesterday) <= drop,
        today.change_from(today)     <= drop].any?,

       history.map {|b| b.volume }.mean >= vol
      ].all?
    end
---

@s When Do We Sell?

As time goes on, more opportunities to invest will arise, and, being a man with
limited impulse control, I am going to invest in them.

=> This means that as time goes on, I am risking more and more of my money.

=> Since I am risking more and more of my money, I get more and more desperate
to get it back.

=> Since I am getting desperate, I am going to lower my standards for the kinds
of returns that I will accept.

#### What Degree of Polynomial?

The line that marks the threshold above which I will sell a stock could be
anything, so from one perspective, I need to try polynomials of all different
degrees. However, a polynomial would imply that there is a grand, overarching
pattern to the way stocks rise after a drop, which I do not believe to be true,
so I'm just looking to manage my risk appropriately.

<br/>

**TODO**: Appropriate risk management could very well involve trying many
different polynomials of many different degrees.

<br/>

Anyways, I figured a linear drop ($y = m * x + b$) would be good enough, so I
ran 1,000 tests on the data to find which curve would give me the best results.
It looked roughly like this:

--- Line Fitting
0.05.step(:to => 0.1, :by => 0.005) do |m|
  m = -m
  1.step(:to => 10, :by => 0.1) do |b|
    assessor.sell_when do |original, today|
      # ...
    end
    sells = assessor.assess_sells

    # ...
  end
end
---

The results were then saved to textfiles and then processed to see which line
would give the best results, thinking I am going to invest the same amount per
investment opportunity (instead of investing the same amount per year, splitting
that amount evenly across an estimated value of opportunities that will occur
during the year).

<br/>

Each row in the data represents one trial: a given year, $m$, and $b$.

--- Fit Results
hash = {}
num = 127 # the number of buying opportunities in 2018-2020

files = Dir['data/roi_*.txt']
data  = files.map do |f|
  txt = File.read f
  txt.split("\n").map {|l| l.split "," }
end.flatten 1

# Conduct a weighted mean
data.each do |r|
  # r = [Timeframe, m, b, Buys, Max ROI, Mean ROI]
  key = [r[1], r[2]] # [m, b]
  hash[key] ||= 0
  hash[key] += r[-1].to_f * r[3].to_f
end
hash.each {|k, v| hash[k] = hash[k] / num.to_f }
hash.max_by {|k, v| v }
---

The maximum ROI seen on that stock is taken from the time that the stock is to
be held (according to the $m$ and $b$ combination) plus 30 days. It allows me to
judge how well the line is meeting the potential on that set of stocks.

--- Max Buy-based Average
[m = -0.05, b = 4.6] => 0.7704006488746548

| Timeframe |   m   |  b  | Buys |   Max ROI   |  Mean ROI  |
|-----------|-------|-----|------|-------------|------------|
|   2018    | -0.05 | 4.6 |   7  | 0.745668795 | 0.669367097|
|   2019    | -0.05 | 4.6 |   8  | 1.311737151 | 0.780366784|
|   2020    | -0.05 | 4.6 |  112 | 1.375183827 | 0.776003379|
---

At this point, it's just a matter of setting up the line:

--- When Do We Sell?
    # drop = -0.3, vol > 10M, m = -0.05, b = 4.6
    @assessor.sell_when do |original, today|
      days_held = today.trading_days_from original
      
      m = -0.05
      b =  4.6
      sell_point = [m * days_held + b, 0].max
    
      today.change_from(original) >= sell_point
    end
---

@s The Simulator

While the assessor provides the framework for routinely and cleanly assessing
the data, the contents of that framework, the actual algorithm, are contained in
the simulator.

--- simulator.rb
class Simulator
  attr_accessor :results
  attr_accessor :assessor
  attr_accessor :stocks
  attr_accessor :after
  attr_accessor :before

  def initialize(stocks: nil, drop: -0.3, vol: 10_000_000, after: nil, before: nil)
    @stocks = stocks
    @after  = after
    @before = before

    @assessor = Assessor.new

    @{When Do We Buy?}

    @{When Do We Sell?}
  end

  def run
    @assessor.assess_buys @stocks, :after  => @after,
                                   :before => @before
    @results = @assessor.assess_sells
  end

end
---

@s The Assessor



--- assessor.rb
class Assessor
  attr_accessor :buying_plan
  attr_accessor :selling_plan
  attr_accessor :history_requirement

  attr_accessor :holding

  def buy_when(history: 2, &b)
    @buying_plan = b
    @history_requirement = history
  end

  def sell_when(&b)
    @selling_plan = b
  end

  def buy?(ticker)
    buying_plan[ticker]
  end

  def sell?(ticker, original)
    selling_plan[ticker, original]
  end

  def assess_buys(tickers, opts={})
    tids = tickers.map {|t| t.id }

    debut  = opts[:after] || Time.parse('1 march 1900')
    debut  = debut.is_a?(Time) ? debut : Time.parse(debut.to_s)
    fin    = opts[:before] || Time.parse(Date.today.to_s)
    fin    = fin.is_a?(Time) ? fin : Time.parse(fin.to_s)

    bars   = Bar.where(:time => debut..fin, :ticker_id => tids)
                .order(:ticker_id, Sequel.asc(:time))
                .all
    groups = bars.group_by {|b| b.ticker_id }

    @holding = []

    # create groups of size `@history_requirement`, and then
    # pass that history to the checker
    # most recent bar is at -1, oldest bar is at 0
    groups.map do |ticker_id, bars|
      # assume the history is 
      histories = bars.each_cons history_requirement

      @holding += histories.filter do |history|

        # verify that the history is consecutive
        day_deltas = history.each_cons(2).map {|a, b| b.date - a.date }

        if day_deltas.any? {|v| v > 4 }
          false
        else
          buy? history
        end
      end.map {|history| history.last }
    end

    # `@holding` currently references the days that a decision to buy is made
    # (using the day's closing price), but we don't *actually* buy until the
    # next morning. So we need to replace these stocks with the next day's
    # stock.
    # 
    # This is key because the `Bar#change_from` method operates on the opening
    # price of the earlier day.
    #
    # If it's `nil` because we're dealing with some HOT OF THE PRESS stock
    # recommendations, then... I don't really have a plan for that yet.
    # Then the stock doesn't exist. Send a text, whatever. I need to include
    # some notification system here.
    #
    # TODO include the notification system at this point.
    #
    # From here on out, we're dealing with *simulation*.
    @holding = @holding.map do |stock|
      index = stock.ticker.bars.index stock
      stock.ticker.bars[index + 1] || stock
    end
    @holding.each {|stock| stock.ticker.normalize! }
    @holding = @holding.map {|stock| stock.refresh }
  end

  def assess_sells
    sales = @holding.map do |stock|
      bars   = stock.ticker.bars
      orig_i = bars.index stock

      sell_bar = bars[orig_i..-1].find {|day| sell? stock, day }

      {:buy  => stock,
       :sell => sell_bar,
       :hold => sell_bar ? sell_bar.trading_days_from(stock)  : nil,
       :ROI  => sell_bar ? sell_bar.change_from(stock) : -1 }
    end
  end

  def assess(tickers, opts={})
    assess_buys tickers, opts
    assess_sells
  end

end
---

@s Accessing Market Data

I use Alpaca.Markets to access market data. At the moment, I only use daily
data. Alpaca's data is unadjusted for splits, and I have found at least one
unresolved issue with their data (January 2018 data for AFL).

--- market.rb
require 'open-uri'
require 'alpaca/trade/api'
require './db.rb'
require './assessor.rb'
require './simulator.rb'
require 'statistics'
require 'histogram/array'

@{Configure the Alpaca API}
---

@s Configure the Alpaca API

As a matter of boilerplate, I need to link up to the Alpaca API in order to
trade.

--- Configure the Alpaca API
Alpaca::Trade::Api.configure do |config|
  config.endpoint   = "https://api.alpaca.markets"
  config.key_id     = "AKM406CX3NH9IO9PGC55"
  config.key_secret = "6NC5iRohh75TkdC6NBvOy2pEKhvYbnBPGPGaRFnM"
end

CLIENT = Alpaca::Trade::Api::Client.new

@{Enhance the Alpaca Ruby API}
--- 

@s Enhance the Alpaca Ruby API

Minor issue with the Ruby API: it only allows you to specify the symbols and
limit the number of results returned. The below change allows you to supply
arbitrary options so that the usage of the `CLIENT.bars` can match the web API.

--- Enhance the Alpaca Ruby API
class Alpaca::Trade::Api::Client
  # This takes care of the issue where I was not able to provide other options
  # to the GET request. Now, I can specify "before" and "after" IAW the API.
  def bars(timeframe, symbols, opts={})
    opts[:limit] ||= 100
    opts[:symbols] = symbols.join(',')

    validate_timeframe(timeframe)
    response = get_request(data_endpoint, "v1/bars/#{timeframe}", opts)
    json = JSON.parse(response.body)
    json.keys.each_with_object({}) do |symbol, hash|
      hash[symbol] = json[symbol].map { |bar| Alpaca::Trade::Api::Bar.new(bar) }
    end
  end 
end
---

