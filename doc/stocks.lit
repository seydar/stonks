@include layout.lit
@title Computer-aided Day Trading

@s Computer-aided Day Trading

The stock market generally overreacts. When good news is published, the price
rises before subsequently falling some amount. When bad news is published, the
price plummets before subsequently rising some amount. One method of automation
would be scanning the news for headlines, measuring the sentiment, and then
investing when the price drops -- the news tells you where to look. Another
option is to scan the entire market and look for drops.

My method is to do exactly that: scan the entire market for a precipitous drop
in price over two days (opening of the first to closing of the second), and
then invest. These stocks tend to rise, collectively, over 100%. How can I
take advantage of that? How do I know when to sell? When should I be
satisfied with a stock's performance?

@s The Process

The process starts simply: we answer the questions of "when do we buy" and "when
do we sell".

A stock price will drop and then it will go back up. We are measuring several
different dimensions for the best outcome, which make this a difficult
(annoying?) problem to solve without the help of more computing power. As an
intermediate step, I've settled on the below figures.

@s When Do We Buy?

What a great question.

First off, what does a "drop in price" look like? What kinds of drops are there?
Reviewing the data from the NYSE for 2019 (1 January - 31 December), we get the
following numbers:

--- Price Change and Occurrences
"Fractional 2-day Change" => "# of Occurrences"
               -100..-0.3 => 99
               -0.3..-0.2 => 243
               -0.2..-0.1 => 2532
               -0.1.. 0   => 267752
                0  .. 0.1 => 309317
                0.1.. 0.2 => 3218
                0.2.. 0.3 => 377
                0.3.. 100 => 151
---

I therefore decided that the 99 occurrences/year would be sufficient for my
tastes; the odds that a >30% drop is an overreaction to some degree is likely
high.

--- When Do We Buy?
    @assessor.buy_when :history => 5 do |history|
      today     = history[-1]
      yesterday = history[-2]
    
      [(today.change_from(yesterday) <= drop or
        today.change_from(today)     <= drop),
       history.map {|b| b.volume }.mean >= vol
      ].all?
    end
---

@s When Do We Sell?

--- When Do We Sell?
    # drop = -0.3, vol > 10M, m = -0.05, b = 4.6
    @assessor.sell_when do |original, today|
      days_held = today.trading_days_from original
      
      m = -0.05
      b =  4.6
      sell_point = [m * days_held + b, 0].max
    
      today.change_from(original) >= sell_point
    end
---

@s The Simulator

While @{The Assessor} provides the framework for routinely and cleanly assessing
the data, the contents of that framework, the actual algorithm, are contained in
the simulator.

--- simulator.rb
class Simulator
  attr_accessor :results
  attr_accessor :assessor
  attr_accessor :stocks
  attr_accessor :after
  attr_accessor :before

  def initialize(stocks: nil, drop: -0.3, vol: 10_000_000, after: nil, before: nil)
    @stocks = stocks
    @after  = after
    @before = before

    @assessor = Assessor.new

    @{When Do We Buy?}

    @{When Do We Sell?}
  end

  def run
    @assessor.assess_buys @stocks, :after  => @after,
                                   :before => @before
    @results = @assessor.assess_sells
  end

end
---

@s The Assessor

--- assessor.rb
class Assessor
  attr_accessor :buying_plan
  attr_accessor :selling_plan
  attr_accessor :history_requirement

  attr_accessor :holding


end
---

@s Accessing Market Data

I use Alpaca.Markets to access market data. At the moment, I only use daily
data. Alpaca's data is unadjusted for splits, and I have found at least one
unresolved issue with their data (January 2018 data for AFL).

--- market.rb
require 'open-uri'
require 'alpaca/trade/api'
require './db.rb'
require './assessor.rb'
require './simulator.rb'
require 'statistics'
require 'histogram/array'

@{Configure the Alpaca API}
---

@s Configure the Alpaca API

As a matter of boilerplate, I need to link up to the Alpaca API in order to
trade.

--- Configure the Alpaca API
Alpaca::Trade::Api.configure do |config|
  config.endpoint   = "https://api.alpaca.markets"
  config.key_id     = "AKM406CX3NH9IO9PGC55"
  config.key_secret = "6NC5iRohh75TkdC6NBvOy2pEKhvYbnBPGPGaRFnM"
end

CLIENT = Alpaca::Trade::Api::Client.new

@{Enhance the Alpaca Ruby API}
--- 

@s Enhance the Alpaca Ruby API

Minor issue with the Ruby API: it only allows you to specify the symbols and
limit the number of results returned. The below change allows you to supply
arbitrary options so that the usage of the `CLIENT.bars` can match the web API.

--- Enhance the Alpaca Ruby API
class Alpaca::Trade::Api::Client
  # This takes care of the issue where I was not able to provide other options
  # to the GET request. Now, I can specify "before" and "after" IAW the API.
  def bars(timeframe, symbols, opts={})
    opts[:limit] ||= 100
    opts[:symbols] = symbols.join(',')

    validate_timeframe(timeframe)
    response = get_request(data_endpoint, "v1/bars/#{timeframe}", opts)
    json = JSON.parse(response.body)
    json.keys.each_with_object({}) do |symbol, hash|
      hash[symbol] = json[symbol].map { |bar| Alpaca::Trade::Api::Bar.new(bar) }
    end
  end 
end
---

