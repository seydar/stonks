@code_type ruby .rb
@comment_type # %s
@include layout.lit
@title Computer-aided Day Trading

@s Computer-aided Day Trading

The stock market generally overreacts. When good news is published, the price
rises before subsequently falling some amount. When bad news is published, the
price plummets before subsequently rising some amount. One method of automation
would be scanning the news for headlines, measuring the sentiment, and then
investing when the price drops -- the news tells you where to look. Another
option is to scan the entire market and look for drops.

My method is to do exactly that: scan the entire market for a precipitous drop
in price over two days (opening of the first to closing of the second), and
then invest. These stocks tend to rise, collectively, over 100%. How can I
take advantage of that? How do I know when to sell? When should I be
satisfied with a stock's performance?

@s The Process

The process starts simply: we answer the questions of "when do we buy" and "when
do we sell".

A stock price will drop and then it will go back up. We are measuring several
different dimensions for the best outcome, which make this a difficult
(annoying?) problem to solve without the help of more computing power. As an
intermediate step, I've settled on the below figures.

@s When Do We Buy?

What a great question.

We buy when the price drops and we are confident that the price will go back up.

#### Price Drop

First off, what does a "drop in price" look like? What kinds of drops are there?
Reviewing the data from the NYSE for 2019 (1 January - 31 December), we get the
following numbers for the fractional 2-day change (from opening of one day to
the close of the next):

--- Price Change and Occurrences
tids  = Ticker.where(:exchange => 'NYSE').all.map {|t| t.id }
debut = Time.parse('1 jan 2019')
fin   = Time.parse('31 dec 2019')
bars  = Bar.where(:time => debut..fin, :ticker_id => tids)
           .order(:ticker_id, Sequel.asc(:time))
           .all
groups  = bars.group_by {|b| b.ticker_id }
changes = groups.map do |ticker_id, bars|
  bars.each_cons(2).map {|a, b| b.change_from a }
end.flatten

hist = changes.histogram [-0.35, -0.25, -0.15, -0.05, 0.05, 0.15, 0.25, 0.35]
---

--- Price Change and Occurrences :=
"Fractional 2-day Change" => "# of Occurrences"
               -100..-0.3 => 99
               -0.3..-0.2 => 243
               -0.2..-0.1 => 2532
               -0.1.. 0   => 267752
                0  .. 0.1 => 309317
                0.1.. 0.2 => 3218
                0.2.. 0.3 => 377
                0.3.. 100 => 151
---

I therefore decided that the 99 occurrences/year would be sufficient for my
tastes; the odds that a >30% drop is an overreaction due to bad news to some
degree is likely high. Thus: we're set the default value in the simulator as
`-0.3`.

#### Price Movement

The logic here is based on my theory of price change: the price of a stock
changes when enough sales have occurred to raise the price (an unenlightening
statement), with $\Delta P_{min}$ being the minimum increase in a stock's price:

<br/>
<div align="center">
$\Delta P_{day} = \Delta P_{min} * N_{trades}$
</div>
<br/>

With a larger minimum price increase, then fewer sales are required to raise the
price to meet a certain threshold. Dividing both sides by $P_{day - 1}$, we get
the fractional change in price:

<br/>
<div align="center">
$\frac{\Delta P_{day}}{P_{day - 1}} = \frac{\Delta P_{min}}{P_{day - 1}} *
N_{trades}$
</div>
<br/>

This now represents the fractional ROI. Assuming the $P_{min}$ is constant for
all stocks, $\frac{\Delta P_{min}}{P_{day - 1}}$ will be greater when $P$ is
lower. We want to maximize $N_{trades}$ and minimize $P$, which is summarized in
our maximization of $\frac{N_{trades}}{P_{day - 1}}$.

The change in price works in both directions, so maximizing the above monomial
could also lead to a sever price drop. But since we're minimizing the $P_{day}$
involved, we're limiting how much the price can drop.

<br/>
**TODO**: This would be a really good thing to check instead of simply volume.
Maybe ensure that a stock is in the top 30% or something? Or meets some minimum
threshold that roughly represents that bracket?

--- Price Theory Optimization
vals = nyse.map do |t|
  if t.bars.empty?
    [t, nil]
  else
    [t, t.volumes(:prior => 10).mean / t.bars[-1].close]
  end
end.to_h
vals.each {|k, v| vals.delete k if v.nil? }
---

#### N<sub>trades</sub>

But because I'm an idiot and didn't do sufficient math as I was developing this
program, I only check for $N_{trades}$ instead of $\frac{N_{trades}}{P_{day -
1}}$. 10,000,000 was chosen because after looking at the trades that dropped,
there were more losers than winners in the < 10,000,000 trades/day crowd. I
found that I could increase my average ROI by culling the herd.

--- When Do We Buy?
    @assessor.buy_when :history => 5 do |history|
      today     = history[-1]
      yesterday = history[-2]
    
      [[today.change_from(yesterday) <= drop,
        today.change_from(today)     <= drop].any?,

       history.map {|b| b.volume }.mean >= vol
      ].all?
    end
---

@s When Do We Sell?

As time goes on, more opportunities to invest will arise, and, being a man with
limited impulse control, I am going to invest in them.

=> This means that as time goes on, I am risking more and more of my money.

=> Since I am risking more and more of my money, I get more and more desperate
to get it back.

=> Since I am getting desperate, I am going to lower my standards for the kinds
of returns that I will accept.

#### What Degree of Polynomial?

The line that marks the threshold above which I will sell a stock could be
anything, so from one perspective, I need to try polynomials of all different
degrees. However, a polynomial would imply that there is a grand, overarching
pattern to the way stocks rise after a drop.

--- When Do We Sell?
    # drop = -0.3, vol > 10M, m = -0.05, b = 4.6
    @assessor.sell_when do |original, today|
      days_held = today.trading_days_from original
      
      m = -0.05
      b =  4.6
      sell_point = [m * days_held + b, 0].max
    
      today.change_from(original) >= sell_point
    end
---

@s The Simulator

While @{The Assessor} provides the framework for routinely and cleanly assessing
the data, the contents of that framework, the actual algorithm, are contained in
the simulator.

--- simulator.rb
class Simulator
  attr_accessor :results
  attr_accessor :assessor
  attr_accessor :stocks
  attr_accessor :after
  attr_accessor :before

  def initialize(stocks: nil, drop: -0.3, vol: 10_000_000, after: nil, before: nil)
    @stocks = stocks
    @after  = after
    @before = before

    @assessor = Assessor.new

    @{When Do We Buy?}

    @{When Do We Sell?}
  end

  def run
    @assessor.assess_buys @stocks, :after  => @after,
                                   :before => @before
    @results = @assessor.assess_sells
  end

end
---

@s The Assessor

--- assessor.rb
class Assessor
  attr_accessor :buying_plan
  attr_accessor :selling_plan
  attr_accessor :history_requirement

  attr_accessor :holding


end
---

@s Accessing Market Data

I use Alpaca.Markets to access market data. At the moment, I only use daily
data. Alpaca's data is unadjusted for splits, and I have found at least one
unresolved issue with their data (January 2018 data for AFL).

--- market.rb
require 'open-uri'
require 'alpaca/trade/api'
require './db.rb'
require './assessor.rb'
require './simulator.rb'
require 'statistics'
require 'histogram/array'

@{Configure the Alpaca API}
---

@s Configure the Alpaca API

As a matter of boilerplate, I need to link up to the Alpaca API in order to
trade.

--- Configure the Alpaca API
Alpaca::Trade::Api.configure do |config|
  config.endpoint   = "https://api.alpaca.markets"
  config.key_id     = "AKM406CX3NH9IO9PGC55"
  config.key_secret = "6NC5iRohh75TkdC6NBvOy2pEKhvYbnBPGPGaRFnM"
end

CLIENT = Alpaca::Trade::Api::Client.new

@{Enhance the Alpaca Ruby API}
--- 

@s Enhance the Alpaca Ruby API

Minor issue with the Ruby API: it only allows you to specify the symbols and
limit the number of results returned. The below change allows you to supply
arbitrary options so that the usage of the `CLIENT.bars` can match the web API.

--- Enhance the Alpaca Ruby API
class Alpaca::Trade::Api::Client
  # This takes care of the issue where I was not able to provide other options
  # to the GET request. Now, I can specify "before" and "after" IAW the API.
  def bars(timeframe, symbols, opts={})
    opts[:limit] ||= 100
    opts[:symbols] = symbols.join(',')

    validate_timeframe(timeframe)
    response = get_request(data_endpoint, "v1/bars/#{timeframe}", opts)
    json = JSON.parse(response.body)
    json.keys.each_with_object({}) do |symbol, hash|
      hash[symbol] = json[symbol].map { |bar| Alpaca::Trade::Api::Bar.new(bar) }
    end
  end 
end
---

